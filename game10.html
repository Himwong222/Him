<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 äº”å­æ£‹æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 800px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 8px;
            color: #fff;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #ffd700, #f0e68c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 1.5px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 25px;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
        }
        
        .game-board {
            flex: 1;
            min-width: 500px;
            max-width: 600px;
            background-color: #deb887;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            padding: 15px;
            position: relative;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 8px;
            background-color: #deb887;
        }
        
        .game-controls {
            flex: 0 0 300px;
            background-color: rgba(30, 30, 46, 0.8);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .game-status {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .current-player {
            font-size: 1.5rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .player-indicator {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .player-black {
            background-color: #000;
            border: 2px solid #fff;
        }
        
        .player-white {
            background-color: #fff;
            border: 2px solid #000;
        }
        
        .game-mode, .difficulty, .controls {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
        }
        
        h2 {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #ffd700;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        button {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .mode-btn {
            background-color: #2d3748;
            color: white;
        }
        
        .mode-btn:hover {
            background-color: #4a5568;
            transform: translateY(-2px);
        }
        
        .mode-btn.active {
            background-color: #38a169;
            box-shadow: 0 0 15px rgba(56, 161, 105, 0.5);
        }
        
        .difficulty-btn {
            background-color: #2d3748;
            color: white;
        }
        
        .difficulty-btn:hover {
            background-color: #4a5568;
            transform: translateY(-2px);
        }
        
        .difficulty-btn.active {
            background-color: #3182ce;
            box-shadow: 0 0 15px rgba(49, 130, 206, 0.5);
        }
        
        .control-btn {
            background-color: #e53e3e;
            color: white;
            font-size: 1.2rem;
        }
        
        .control-btn:hover {
            background-color: #c53030;
            transform: translateY(-2px);
        }
        
        .control-btn.restart {
            background-color: #38a169;
        }
        
        .control-btn.restart:hover {
            background-color: #2f855a;
        }
        
        .rules {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #aaa;
            line-height: 1.5;
        }
        
        .winner-message {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7);
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        .footer {
            margin-top: 30px;
            text-align: center;
            color: #777;
            font-size: 0.9rem;
            max-width: 800px;
        }
        
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-board {
                min-width: 95%;
            }
            
            .game-controls {
                width: 95%;
                max-width: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>äº”å­æ£‹æ¸¸æˆ</h1>
        <p class="subtitle">æ¨ªã€ç«–ã€æ–œè¿æˆäº”å­å³ä¸ºèƒœåˆ©ï¼é»‘æ£‹å…ˆè¡Œ</p>
    </div>
    
    <div class="game-container">
        <div class="game-board">
            <canvas id="gameCanvas" width="570" height="570"></canvas>
        </div>
        
        <div class="game-controls">
            <div class="game-status">
                <div class="current-player">
                    <span>å½“å‰å›åˆ:</span>
                    <span id="currentPlayerText">é»‘æ£‹</span>
                    <span class="player-indicator player-black"></span>
                </div>
                <div id="winnerMessage" class="winner-message"></div>
            </div>
            
            <div class="game-mode">
                <h2>æ¸¸æˆæ¨¡å¼</h2>
                <div class="btn-group">
                    <button id="twoPlayerBtn" class="mode-btn active">
                        <span>ğŸ‘¥ åŒäººå¯¹æˆ˜</span>
                    </button>
                    <button id="aiPlayerBtn" class="mode-btn">
                        <span>ğŸ¤– äººæœºå¯¹æˆ˜</span>
                    </button>
                </div>
            </div>
            
            <div class="difficulty">
                <h2>AIéš¾åº¦</h2>
                <div class="btn-group">
                    <button id="easyBtn" class="difficulty-btn">
                        <span>ğŸ˜Š ç®€å•</span>
                    </button>
                    <button id="mediumBtn" class="difficulty-btn active">
                        <span>ğŸ˜ ä¸­ç­‰</span>
                    </button>
                    <button id="hardBtn" class="difficulty-btn">
                        <span>ğŸ¤¯ å›°éš¾</span>
                    </button>
                </div>
            </div>
            
            <div class="controls">
                <h2>æ¸¸æˆæ§åˆ¶</h2>
                <div class="btn-group">
                    <button id="restartBtn" class="control-btn restart">
                        <span>ğŸ”„ é‡æ–°å¼€å§‹</span>
                    </button>
                    <button id="undoBtn" class="control-btn">
                        <span>â†©ï¸ æ‚”æ£‹ä¸€æ­¥</span>
                    </button>
                </div>
            </div>
            
            <div class="rules">
                <h2>æ¸¸æˆè§„åˆ™</h2>
                <p>1. é»‘æ£‹å…ˆè¡Œï¼ŒåŒæ–¹è½®æµåœ¨æ£‹ç›˜ä¸Šæ”¾ç½®æ£‹å­</p>
                <p>2. å…ˆåœ¨æ¨ªã€ç«–ã€æ–œæ–¹å‘è¿æˆäº”å­è€…è·èƒœ</p>
                <p>3. æ£‹ç›˜å¤§å°ä¸º15Ã—15ï¼Œæ£‹å­ä¸‹åœ¨äº¤å‰ç‚¹ä¸Š</p>
                <p>4. äººæœºå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼ŒAIä¼šæ ¹æ®éš¾åº¦çº§åˆ«è¿›è¡Œå†³ç­–</p>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>HTML5äº”å­æ£‹æ¸¸æˆ - ä½¿ç”¨Canvaså’ŒJavaScriptå®ç° Â© 2023</p>
    </div>

    <script>
        // æ¸¸æˆå˜é‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 15; // 15x15æ£‹ç›˜
        const cellSize = canvas.width / (gridSize + 1);
        let board = Array(gridSize).fill().map(() => Array(gridSize).fill(0)); // 0=ç©º, 1=é»‘, 2=ç™½
        let currentPlayer = 1; // 1=é»‘æ£‹, 2=ç™½æ£‹
        let gameMode = 'twoPlayer'; // 'twoPlayer' æˆ– 'ai'
        let difficulty = 'medium'; // 'easy', 'medium', 'hard'
        let gameActive = true;
        let moveHistory = [];
        
        // DOMå…ƒç´ 
        const currentPlayerText = document.getElementById('currentPlayerText');
        const winnerMessage = document.getElementById('winnerMessage');
        const twoPlayerBtn = document.getElementById('twoPlayerBtn');
        const aiPlayerBtn = document.getElementById('aiPlayerBtn');
        const easyBtn = document.getElementById('easyBtn');
        const mediumBtn = document.getElementById('mediumBtn');
        const hardBtn = document.getElementById('hardBtn');
        const restartBtn = document.getElementById('restartBtn');
        const undoBtn = document.getElementById('undoBtn');
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            board = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
            currentPlayer = 1;
            gameActive = true;
            moveHistory = [];
            winnerMessage.textContent = '';
            updatePlayerDisplay();
            drawBoard();
        }
        
        // ç»˜åˆ¶æ£‹ç›˜
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ£‹ç›˜èƒŒæ™¯
            ctx.fillStyle = '#deb887';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            
            // å‚ç›´çº¿
            for (let i = 0; i < gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo((i + 1) * cellSize, cellSize);
                ctx.lineTo((i + 1) * cellSize, canvas.height - cellSize);
                ctx.stroke();
            }
            
            // æ°´å¹³çº¿
            for (let i = 0; i < gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(cellSize, (i + 1) * cellSize);
                ctx.lineTo(canvas.width - cellSize, (i + 1) * cellSize);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶æ£‹ç›˜ä¸Šçš„äº”ä¸ªç‚¹ï¼ˆå¤©å…ƒå’Œæ˜Ÿï¼‰
            const dots = [
                {x: 3, y: 3}, {x: 3, y: 11}, {x: 7, y: 7},
                {x: 11, y: 3}, {x: 11, y: 11}
            ];
            
            ctx.fillStyle = '#000';
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(
                    (dot.x + 1) * cellSize,
                    (dot.y + 1) * cellSize,
                    4, 0, Math.PI * 2
                );
                ctx.fill();
            });
            
            // ç»˜åˆ¶æ£‹å­
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] !== 0) {
                        drawPiece(col, row, board[row][col]);
                    }
                }
            }
            
            // ç»˜åˆ¶æœ€åä¸€æ­¥çš„æç¤º
            if (moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(
                    (lastMove.col + 1) * cellSize,
                    (lastMove.row + 1) * cellSize,
                    cellSize * 0.4, 0, Math.PI * 2
                );
                ctx.stroke();
            }
        }
        
        // ç»˜åˆ¶æ£‹å­
        function drawPiece(col, row, player) {
            const x = (col + 1) * cellSize;
            const y = (row + 1) * cellSize;
            const radius = cellSize * 0.45;
            
            // åˆ›å»ºæ£‹å­æ¸å˜
            const gradient = ctx.createRadialGradient(
                x - radius/3, y - radius/3, 1,
                x, y, radius
            );
            
            if (player === 1) { // é»‘æ£‹
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(1, '#000');
            } else { // ç™½æ£‹
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ddd');
            }
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // æ£‹å­è¾¹æ¡†
            ctx.strokeStyle = player === 1 ? '#333' : '#aaa';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // æ›´æ–°ç©å®¶æ˜¾ç¤º
        function updatePlayerDisplay() {
            if (!gameActive) return;
            
            const playerText = currentPlayer === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹';
            currentPlayerText.textContent = playerText;
            
            // æ›´æ–°æŒ‡ç¤ºå™¨é¢œè‰²
            const playerIndicator = document.querySelector('.current-player .player-indicator');
            playerIndicator.className = 'player-indicator';
            playerIndicator.classList.add(currentPlayer === 1 ? 'player-black' : 'player-white');
        }
        
        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
        function checkWin(row, col, player) {
            // æ£€æŸ¥æ–¹å‘: æ°´å¹³, å‚ç›´, å·¦ä¸Šåˆ°å³ä¸‹, å³ä¸Šåˆ°å·¦ä¸‹
            const directions = [
                [0, 1],  // æ°´å¹³
                [1, 0],  // å‚ç›´
                [1, 1],  // å¯¹è§’çº¿å·¦ä¸Šåˆ°å³ä¸‹
                [1, -1]  // å¯¹è§’çº¿å³ä¸Šåˆ°å·¦ä¸‹
            ];
            
            for (const [dx, dy] of directions) {
                let count = 1; // å½“å‰ä½ç½®çš„æ£‹å­
                
                // æ­£å‘æ£€æŸ¥
                for (let i = 1; i < 5; i++) {
                    const newRow = row + i * dx;
                    const newCol = col + i * dy;
                    
                    if (
                        newRow >= 0 && newRow < gridSize &&
                        newCol >= 0 && newCol < gridSize &&
                        board[newRow][newCol] === player
                    ) {
                        count++;
                    } else {
                        break;
                    }
                }
                
                // åå‘æ£€æŸ¥
                for (let i = 1; i < 5; i++) {
                    const newRow = row - i * dx;
                    const newCol = col - i * dy;
                    
                    if (
                        newRow >= 0 && newRow < gridSize &&
                        newCol >= 0 && newCol < gridSize &&
                        board[newRow][newCol] === player
                    ) {
                        count++;
                    } else {
                        break;
                    }
                }
                
                if (count >= 5) {
                    return true;
                }
            }
            
            return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦å¹³å±€
        function checkDraw() {
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // å¤„ç†ç©å®¶è½å­
        function makeMove(row, col) {
            if (!gameActive || board[row][col] !== 0) return false;
            
            // è®°å½•ç§»åŠ¨å†å²
            moveHistory.push({row, col, player: currentPlayer});
            
            // è½å­
            board[row][col] = currentPlayer;
            drawBoard();
            
            // æ£€æŸ¥èƒœåˆ©
            if (checkWin(row, col, currentPlayer)) {
                gameActive = false;
                const winner = currentPlayer === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹';
                winnerMessage.textContent = `${winner} è·èƒœ!`;
                return true;
            }
            
            // æ£€æŸ¥å¹³å±€
            if (checkDraw()) {
                gameActive = false;
                winnerMessage.textContent = "å¹³å±€!";
                return true;
            }
            
            // åˆ‡æ¢ç©å®¶
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updatePlayerDisplay();
            
            // å¦‚æœæ˜¯AIæ¨¡å¼ä¸”è½®åˆ°AI
            if (gameMode === 'ai' && currentPlayer === 2 && gameActive) {
                setTimeout(() => {
                    aiMakeMove();
                }, 500);
            }
            
            return true;
        }
        
        // AIè½å­
        function aiMakeMove() {
            if (!gameActive || currentPlayer !== 2) return;
            
            let move;
            
            // æ ¹æ®éš¾åº¦é€‰æ‹©AIç­–ç•¥
            if (difficulty === 'easy') {
                move = getRandomMove();
            } else if (difficulty === 'medium') {
                move = getMediumMove();
            } else { // hard
                move = getHardMove();
            }
            
            if (move) {
                makeMove(move.row, move.col);
            }
        }
        
        // éšæœºç§»åŠ¨ (ç®€å•éš¾åº¦)
        function getRandomMove() {
            // å°è¯•æ‰¾åˆ°å¯ä»¥èµ¢çš„ä½ç½®
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        board[row][col] = 2;
                        if (checkWin(row, col, 2)) {
                            board[row][col] = 0;
                            return {row, col};
                        }
                        board[row][col] = 0;
                    }
                }
            }
            
            // å°è¯•é˜»æ­¢ç©å®¶èµ¢
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        board[row][col] = 1;
                        if (checkWin(row, col, 1)) {
                            board[row][col] = 0;
                            return {row, col};
                        }
                        board[row][col] = 0;
                    }
                }
            }
            
            // å¦åˆ™éšæœºé€‰æ‹©ç©ºä½
            const emptyCells = [];
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        emptyCells.push({row, col});
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                return emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }
            
            return null;
        }
        
        // ä¸­ç­‰éš¾åº¦AI
        function getMediumMove() {
            // é¦–å…ˆæ£€æŸ¥AIæ˜¯å¦æœ‰è·èƒœæœºä¼š
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        board[row][col] = 2;
                        if (checkWin(row, col, 2)) {
                            board[row][col] = 0;
                            return {row, col};
                        }
                        board[row][col] = 0;
                    }
                }
            }
            
            // æ£€æŸ¥ç©å®¶æ˜¯å¦æœ‰è·èƒœæœºä¼šå¹¶é˜»æ­¢
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        board[row][col] = 1;
                        if (checkWin(row, col, 1)) {
                            board[row][col] = 0;
                            return {row, col};
                        }
                        board[row][col] = 0;
                    }
                }
            }
            
            // å°è¯•åˆ›å»ºæˆ–é˜»æ­¢å››å­è¿ç 
            const bestMove = evaluateBoard();
            if (bestMove) return bestMove;
            
            // å¦‚æœä¸Šè¿°éƒ½ä¸è¡Œï¼Œåˆ™éšæœºé€‰æ‹©
            return getRandomMove();
        }
        
        // å›°éš¾éš¾åº¦AI
        function getHardMove() {
            // ä½¿ç”¨Minimaxç®—æ³•è¿›è¡Œæ›´æ·±å…¥çš„æœç´¢
            const depth = 2; // æœç´¢æ·±åº¦
            const bestMove = minimax(depth, 2, -Infinity, Infinity);
            return bestMove.move;
        }
        
        // ç®€å•è¯„ä¼°å‡½æ•°
        function evaluateBoard() {
            let bestScore = -Infinity;
            let bestMove = null;
            
            // éå†æ‰€æœ‰å¯èƒ½çš„ä½ç½®
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        // å°è¯•åœ¨æ­¤ä½ç½®è½å­
                        board[row][col] = 2;
                        
                        // è®¡ç®—åˆ†æ•°
                        let score = evaluatePosition(row, col, 2);
                        
                        // å¦‚æœè¿™æ˜¯ä¸­å¿ƒåŒºåŸŸï¼Œå¢åŠ åˆ†æ•°
                        const centerDist = Math.abs(row - 7) + Math.abs(col - 7);
                        score += (14 - centerDist) * 10;
                        
                        // æ¢å¤æ£‹ç›˜
                        board[row][col] = 0;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = {row, col};
                        }
                    }
                }
            }
            
            return bestMove;
        }
        
        // è¯„ä¼°ä½ç½®åˆ†æ•°
        function evaluatePosition(row, col, player) {
            let score = 0;
            
            // æ£€æŸ¥å››ä¸ªæ–¹å‘
            const directions = [
                [0, 1],  // æ°´å¹³
                [1, 0],  // å‚ç›´
                [1, 1],  // å¯¹è§’çº¿å·¦ä¸Šåˆ°å³ä¸‹
                [1, -1]  // å¯¹è§’çº¿å³ä¸Šåˆ°å·¦ä¸‹
            ];
            
            for (const [dx, dy] of directions) {
                let playerCount = 1; // å½“å‰ç©å®¶çš„è¿ç»­æ£‹å­æ•°
                let openEnds = 0;
                
                // æ­£å‘æ£€æŸ¥
                for (let i = 1; i < 5; i++) {
                    const newRow = row + i * dx;
                    const newCol = col + i * dy;
                    
                    if (
                        newRow >= 0 && newRow < gridSize &&
                        newCol >= 0 && newCol < gridSize
                    ) {
                        if (board[newRow][newCol] === player) {
                            playerCount++;
                        } else if (board[newRow][newCol] === 0) {
                            openEnds++;
                            break;
                        } else {
                            break;
                        }
                    }
                }
                
                // åå‘æ£€æŸ¥
                for (let i = 1; i < 5; i++) {
                    const newRow = row - i * dx;
                    const newCol = col - i * dy;
                    
                    if (
                        newRow >= 0 && newRow < gridSize &&
                        newCol >= 0 && newCol < gridSize
                    ) {
                        if (board[newRow][newCol] === player) {
                            playerCount++;
                        } else if (board[newRow][newCol] === 0) {
                            openEnds++;
                            break;
                        } else {
                            break;
                        }
                    }
                }
                
                // æ ¹æ®è¿ç»­æ£‹å­å’Œå¼€æ”¾ç«¯è®¡ç®—åˆ†æ•°
                if (playerCount >= 5) {
                    score += 10000; // è·èƒœ
                } else if (playerCount === 4) {
                    score += openEnds === 2 ? 1000 : 500;
                } else if (playerCount === 3) {
                    score += openEnds === 2 ? 200 : 50;
                } else if (playerCount === 2) {
                    score += openEnds === 2 ? 10 : 5;
                }
            }
            
            return score;
        }
        
        // Minimaxç®—æ³•
        function minimax(depth, player, alpha, beta) {
            // å¦‚æœè¾¾åˆ°æ·±åº¦é™åˆ¶æˆ–æ¸¸æˆç»“æŸï¼Œè¿”å›è¯„ä¼°å€¼
            if (depth === 0) {
                return {score: evaluateBoardForMinimax()};
            }
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            let gameOver = false;
            let winner = null;
            
            for (let row = 0; row < gridSize && !gameOver; row++) {
                for (let col = 0; col < gridSize && !gameOver; col++) {
                    if (board[row][col] !== 0) {
                        if (checkWin(row, col, board[row][col])) {
                            gameOver = true;
                            winner = board[row][col];
                        }
                    }
                }
            }
            
            if (gameOver) {
                if (winner === 2) {
                    return {score: 10000 + depth}; // AIèµ¢
                } else if (winner === 1) {
                    return {score: -10000 - depth}; // ç©å®¶èµ¢
                } else {
                    return {score: 0}; // å¹³å±€
                }
            }
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨
            const moves = [];
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 0) {
                        moves.push({row, col});
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰åˆæ³•ç§»åŠ¨ï¼Œè¿”å›0
            if (moves.length === 0) {
                return {score: 0};
            }
            
            let bestMove;
            
            if (player === 2) { // AI (æœ€å¤§åŒ–ç©å®¶)
                let maxScore = -Infinity;
                
                for (const move of moves) {
                    // å°è¯•ç§»åŠ¨
                    board[move.row][move.col] = 2;
                    
                    // é€’å½’è°ƒç”¨
                    const result = minimax(depth - 1, 1, alpha, beta);
                    
                    // æ¢å¤æ£‹ç›˜
                    board[move.row][move.col] = 0;
                    
                    if (result.score > maxScore) {
                        maxScore = result.score;
                        bestMove = move;
                    }
                    
                    alpha = Math.max(alpha, result.score);
                    if (beta <= alpha) {
                        break; // Betaå‰ªæ
                    }
                }
                
                return {score: maxScore, move: bestMove};
            } else { // ç©å®¶ (æœ€å°åŒ–ç©å®¶)
                let minScore = Infinity;
                
                for (const move of moves) {
                    // å°è¯•ç§»åŠ¨
                    board[move.row][move.col] = 1;
                    
                    // é€’å½’è°ƒç”¨
                    const result = minimax(depth - 1, 2, alpha, beta);
                    
                    // æ¢å¤æ£‹ç›˜
                    board[move.row][move.col] = 0;
                    
                    if (result.score < minScore) {
                        minScore = result.score;
                        bestMove = move;
                    }
                    
                    beta = Math.min(beta, result.score);
                    if (beta <= alpha) {
                        break; // Alphaå‰ªæ
                    }
                }
                
                return {score: minScore, move: bestMove};
            }
        }
        
        // ä¸ºMinimaxè¯„ä¼°æ£‹ç›˜
        function evaluateBoardForMinimax() {
            let score = 0;
            
            // ç®€å•è¯„ä¼°ï¼šè®¡ç®—AIçš„æ½œåœ¨è¿å­æ•°å‡å»ç©å®¶çš„æ½œåœ¨è¿å­æ•°
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === 2) {
                        score += evaluatePosition(row, col, 2);
                    } else if (board[row][col] === 1) {
                        score -= evaluatePosition(row, col, 1);
                    }
                }
            }
            
            return score;
        }
        
        // å¤„ç†æ‚”æ£‹
        function undoMove() {
            if (moveHistory.length === 0 || !gameActive) return;
            
            // å¦‚æœæ˜¯AIæ¨¡å¼ä¸”ä¸Šä¸€æ­¥æ˜¯AIèµ°çš„ï¼Œéœ€è¦æ‚”ä¸¤æ­¥
            let stepsToUndo = 1;
            if (gameMode === 'ai' && currentPlayer === 1 && moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                if (lastMove.player === 2) {
                    stepsToUndo = 2;
                }
            }
            
            // æœ€å¤šæ‚”ä¸¤æ­¥æ£‹
            stepsToUndo = Math.min(stepsToUndo, moveHistory.length);
            
            for (let i = 0; i < stepsToUndo; i++) {
                const lastMove = moveHistory.pop();
                if (lastMove) {
                    board[lastMove.row][lastMove.col] = 0;
                    currentPlayer = lastMove.player;
                }
            }
            
            gameActive = true;
            winnerMessage.textContent = '';
            updatePlayerDisplay();
            drawBoard();
        }
        
        // å¤„ç†ç”»å¸ƒç‚¹å‡»äº‹ä»¶
        canvas.addEventListener('click', (e) => {
            if (!gameActive) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // è®¡ç®—ç‚¹å‡»çš„ç½‘æ ¼ä½ç½®
            const col = Math.round(x / cellSize) - 1;
            const row = Math.round(y / cellSize) - 1;
            
            // ç¡®ä¿ç‚¹å‡»åœ¨æ£‹ç›˜èŒƒå›´å†…
            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
                // åœ¨åŒäººæ¨¡å¼ä¸‹ï¼Œä»»ä½•äººéƒ½å¯ä»¥ä¸‹æ£‹
                // åœ¨AIæ¨¡å¼ä¸‹ï¼Œåªæœ‰å½“å‰ç©å®¶æ˜¯1(äººç±»)æ—¶æ‰å…è®¸ä¸‹æ£‹
                if (gameMode === 'twoPlayer' || (gameMode === 'ai' && currentPlayer === 1)) {
                    makeMove(row, col);
                }
            }
        });
        
        // äº‹ä»¶ç›‘å¬å™¨
        twoPlayerBtn.addEventListener('click', () => {
            gameMode = 'twoPlayer';
            twoPlayerBtn.classList.add('active');
            aiPlayerBtn.classList.remove('active');
            initGame();
        });
        
        aiPlayerBtn.addEventListener('click', () => {
            gameMode = 'ai';
            aiPlayerBtn.classList.add('active');
            twoPlayerBtn.classList.remove('active');
            initGame();
        });
        
        easyBtn.addEventListener('click', () => {
            difficulty = 'easy';
            easyBtn.classList.add('active');
            mediumBtn.classList.remove('active');
            hardBtn.classList.remove('active');
        });
        
        mediumBtn.addEventListener('click', () => {
            difficulty = 'medium';
            mediumBtn.classList.add('active');
            easyBtn.classList.remove('active');
            hardBtn.classList.remove('active');
        });
        
        hardBtn.addEventListener('click', () => {
            difficulty = 'hard';
            hardBtn.classList.add('active');
            easyBtn.classList.remove('active');
            mediumBtn.classList.remove('active');
        });
        
        restartBtn.addEventListener('click', initGame);
        
        undoBtn.addEventListener('click', undoMove);
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>