<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>传统中国象棋 - 已修复</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
        }
        
        body {
            background-color: #f5f5dc;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        h1 {
            color: #8B4513;
            font-size: 2.8rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
            letter-spacing: 5px;
        }
        
        .subtitle {
            color: #654321;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1400px;
            width: 100%;
        }
        
        .game-section {
            flex: 1;
            min-width: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .control-section {
            flex-basis: 400px;
            background-color: #f9f3e9;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
            border: 2px solid #8B4513;
        }
        
        #chessboard {
            background-color: #EACDA9;
            border: 10px solid #8B4513;
            border-radius: 5px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.25);
        }
        
        .status-bar {
            background-color: #8B4513;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 1.3rem;
            text-align: center;
            width: 100%;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-panel {
            margin-bottom: 25px;
        }
        
        .mode-selection {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .mode-btn {
            padding: 15px;
            font-size: 1.2rem;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .mode-btn:hover {
            background-color: #A0522D;
            transform: translateY(-3px);
        }
        
        .mode-btn.active {
            background-color: #654321;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .difficulty-selection {
            margin-top: 20px;
            padding: 20px;
            background-color: #f0e6d6;
            border-radius: 10px;
            border: 1px solid #8B4513;
            display: none;
        }
        
        .difficulty-selection h3 {
            color: #654321;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .difficulty-options {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .difficulty-btn {
            flex: 1;
            padding: 12px;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .difficulty-btn:hover {
            background-color: #A0522D;
        }
        
        .difficulty-btn.active {
            background-color: #654321;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.3);
        }
        
        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }
        
        .control-btn {
            padding: 15px;
            font-size: 1.1rem;
            background-color: #2E8B57;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background-color: #3CB371;
            transform: translateY(-3px);
        }
        
        .control-btn.reset {
            background-color: #CD5C5C;
        }
        
        .control-btn.reset:hover {
            background-color: #DC143C;
        }
        
        .rules {
            margin-top: 30px;
            padding: 20px;
            background-color: #f0e6d6;
            border-radius: 10px;
            border: 1px solid #8B4513;
        }
        
        .rules h3 {
            color: #654321;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .rules ul {
            padding-left: 20px;
            color: #333;
        }
        
        .rules li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .piece-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #654321;
        }
        
        .red-turn, .black-turn {
            font-weight: bold;
        }
        
        .red-turn {
            color: #D22B2B;
        }
        
        .black-turn {
            color: #000;
        }
        
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-section {
                min-width: 100%;
            }
            
            .control-section {
                width: 100%;
                max-width: 700px;
            }
        }
        
        @media (max-width: 768px) {
            #chessboard {
                width: 95vw;
                height: 95vw;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
        
        .footer {
            margin-top: 30px;
            color: #654321;
            text-align: center;
            font-size: 0.9rem;
            padding: 20px;
            width: 100%;
        }
        
        .debug-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            font-size: 0.9rem;
            color: #666;
            display: none;
        }
        
        .debug-toggle {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #ddd;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>中國象棋</h1>
        <div class="subtitle">传统版 - 已修复棋子移动问题</div>
    </div>
    
    <div class="container">
        <div class="game-section">
            <canvas id="chessboard" width="700" height="700"></canvas>
            <div class="status-bar" id="status">请选择游戏模式</div>
            <button class="debug-toggle" id="debug-toggle">显示调试信息</button>
            <div class="debug-info" id="debug-info">调试信息将显示在这里</div>
        </div>
        
        <div class="control-section">
            <div class="control-panel">
                <h2>游戏设置</h2>
                <div class="mode-selection">
                    <button class="mode-btn" id="two-player-mode">双人对决</button>
                    <button class="mode-btn" id="ai-mode">人机对决</button>
                </div>
                
                <div class="difficulty-selection" id="difficulty-section">
                    <h3>选择难度级别</h3>
                    <div class="difficulty-options">
                        <button class="difficulty-btn" id="easy">简单</button>
                        <button class="difficulty-btn" id="medium">中等</button>
                        <button class="difficulty-btn" id="hard">困难</button>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="control-btn" id="start-game">开始游戏</button>
                    <button class="control-btn reset" id="reset-game">重新开始</button>
                    <button class="control-btn" id="undo-move">悔棋一步</button>
                </div>
            </div>
            
            <div class="rules">
                <h3>操作说明</h3>
                <ul>
                    <li><strong>红方先走</strong>，点击自己的棋子选择</li>
                    <li>再次点击目标位置移动棋子</li>
                    <li>绿色圆点表示可以移动的位置</li>
                    <li>如果棋子无法移动，请检查：
                        <ul>
                            <li>是否轮到你走棋（看状态栏）</li>
                            <li>是否符合棋子移动规则</li>
                            <li>是否点击了正确的目标位置</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <div class="piece-info">
                <div class="red-turn">红方：将、士、象、马、车、炮、兵</div>
                <div class="black-turn">黑方：帅、仕、相、马、车、炮、卒</div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        传统中国象棋游戏 - 使用HTML5 Canvas开发 | 已修复棋子移动问题
    </div>

    <script>
        // 游戏状态
        const gameState = {
            board: [],
            currentPlayer: 'red', // 'red' 或 'black'
            gameMode: null, // 'two-player' 或 'ai'
            difficulty: 'medium', // 'easy', 'medium', 'hard'
            gameStarted: false,
            selectedPiece: null,
            moveHistory: [],
            aiThinking: false
        };

        // 棋盘和棋子常量 - 修复：中国象棋棋盘是10行9列
        const ROWS = 10;
        const COLS = 9;
        const CELL_SIZE = 70;
        const PIECE_RADIUS = 30;
        
        // 棋子类型
        const PIECE_TYPES = {
            KING: '将',      // 将/帅
            GUARD: '士',     // 士/仕
            ELEPHANT: '象',  // 象/相
            HORSE: '马',     // 马
            CHARIOT: '车',   // 车
            CANNON: '炮',    // 炮
            PAWN: '兵'       // 兵/卒
        };
        
        // 初始化棋盘
        function initBoard() {
            // 创建空棋盘 - 修复：使用正确的行列数
            gameState.board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            
            // 放置黑方棋子
            gameState.board[0][0] = {type: PIECE_TYPES.CHARIOT, color: 'black'};
            gameState.board[0][1] = {type: PIECE_TYPES.HORSE, color: 'black'};
            gameState.board[0][2] = {type: PIECE_TYPES.ELEPHANT, color: 'black'};
            gameState.board[0][3] = {type: PIECE_TYPES.GUARD, color: 'black'};
            gameState.board[0][4] = {type: PIECE_TYPES.KING, color: 'black'};
            gameState.board[0][5] = {type: PIECE_TYPES.GUARD, color: 'black'};
            gameState.board[0][6] = {type: PIECE_TYPES.ELEPHANT, color: 'black'};
            gameState.board[0][7] = {type: PIECE_TYPES.HORSE, color: 'black'};
            gameState.board[0][8] = {type: PIECE_TYPES.CHARIOT, color: 'black'};
            gameState.board[2][1] = {type: PIECE_TYPES.CANNON, color: 'black'};
            gameState.board[2][7] = {type: PIECE_TYPES.CANNON, color: 'black'};
            gameState.board[3][0] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][2] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][4] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][6] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][8] = {type: PIECE_TYPES.PAWN, color: 'black'};
            
            // 放置红方棋子
            gameState.board[9][0] = {type: PIECE_TYPES.CHARIOT, color: 'red'};
            gameState.board[9][1] = {type: PIECE_TYPES.HORSE, color: 'red'};
            gameState.board[9][2] = {type: PIECE_TYPES.ELEPHANT, color: 'red'};
            gameState.board[9][3] = {type: PIECE_TYPES.GUARD, color: 'red'};
            gameState.board[9][4] = {type: PIECE_TYPES.KING, color: 'red'};
            gameState.board[9][5] = {type: PIECE_TYPES.GUARD, color: 'red'};
            gameState.board[9][6] = {type: PIECE_TYPES.ELEPHANT, color: 'red'};
            gameState.board[9][7] = {type: PIECE_TYPES.HORSE, color: 'red'};
            gameState.board[9][8] = {type: PIECE_TYPES.CHARIOT, color: 'red'};
            gameState.board[7][1] = {type: PIECE_TYPES.CANNON, color: 'red'};
            gameState.board[7][7] = {type: PIECE_TYPES.CANNON, color: 'red'};
            gameState.board[6][0] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][2] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][4] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][6] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][8] = {type: PIECE_TYPES.PAWN, color: 'red'};
            
            // 重置游戏状态
            gameState.currentPlayer = 'red';
            gameState.selectedPiece = null;
            gameState.moveHistory = [];
            gameState.aiThinking = false;
            
            updateStatus();
            
            // 添加调试信息
            logDebug('棋盘初始化完成，红方先走');
        }
        
        // 绘制棋盘
        function drawBoard() {
            const canvas = document.getElementById('chessboard');
            const ctx = canvas.getContext('2d');
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制棋盘背景
            ctx.fillStyle = '#EACDA9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制棋盘格子
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            
            // 绘制横线
            for (let i = 0; i < ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                ctx.lineTo(canvas.width - CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                ctx.stroke();
            }
            
            // 绘制竖线
            for (let i = 0; i < COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 2);
                ctx.lineTo(i * CELL_SIZE + CELL_SIZE / 2, canvas.height - CELL_SIZE / 2);
                ctx.stroke();
            }
            
            // 绘制九宫格
            ctx.lineWidth = 2;
            ctx.beginPath();
            // 上九宫格（黑方）
            ctx.moveTo(3 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(5 * CELL_SIZE + CELL_SIZE / 2, 2 * CELL_SIZE + CELL_SIZE / 2);
            ctx.moveTo(5 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(3 * CELL_SIZE + CELL_SIZE / 2, 2 * CELL_SIZE + CELL_SIZE / 2);
            // 下九宫格（红方）
            ctx.moveTo(3 * CELL_SIZE + CELL_SIZE / 2, 7 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(5 * CELL_SIZE + CELL_SIZE / 2, 9 * CELL_SIZE + CELL_SIZE / 2);
            ctx.moveTo(5 * CELL_SIZE + CELL_SIZE / 2, 7 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(3 * CELL_SIZE + CELL_SIZE / 2, 9 * CELL_SIZE + CELL_SIZE / 2);
            ctx.stroke();
            
            // 绘制棋子
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        drawPiece(ctx, col, row, piece);
                    }
                }
            }
            
            // 绘制选中的棋子
            if (gameState.selectedPiece) {
                const {row, col} = gameState.selectedPiece;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                    col * CELL_SIZE + CELL_SIZE / 2,
                    row * CELL_SIZE + CELL_SIZE / 2,
                    PIECE_RADIUS + 5,
                    0,
                    Math.PI * 2
                );
                ctx.stroke();
                
                // 绘制可移动位置
                const moves = getValidMoves(row, col, gameState.board);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                for (const move of moves) {
                    ctx.beginPath();
                    ctx.arc(
                        move.col * CELL_SIZE + CELL_SIZE / 2,
                        move.row * CELL_SIZE + CELL_SIZE / 2,
                        8,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // 调试信息
                logDebug(`选中棋子: ${gameState.board[row][col].type} (${gameState.board[row][col].color}) 在位置 (${row}, ${col})`);
                logDebug(`可移动位置: ${moves.length} 个`);
            }
            
            // 绘制楚河汉界
            ctx.fillStyle = '#000';
            ctx.font = 'bold 30px SimHei';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('楚河', 4.5 * CELL_SIZE, 4.8 * CELL_SIZE);
            ctx.fillText('汉界', 4.5 * CELL_SIZE, 5.2 * CELL_SIZE);
        }
        
        // 绘制棋子
        function drawPiece(ctx, col, row, piece) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            
            // 绘制棋子背景
            const gradient = ctx.createRadialGradient(x, y, 5, x, y, PIECE_RADIUS);
            if (piece.color === 'red') {
                gradient.addColorStop(0, '#FF6B6B');
                gradient.addColorStop(1, '#D22B2B');
            } else {
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(1, '#000');
            }
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, PIECE_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制棋子边框
            ctx.strokeStyle = piece.color === 'red' ? '#8B0000' : '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制棋子文字
            ctx.fillStyle = piece.color === 'red' ? '#FFD700' : '#FFF';
            ctx.font = 'bold 28px SimHei';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(piece.type, x, y);
        }
        
        // 获取棋子的合法移动 - 修复移动规则
        function getValidMoves(row, col, board) {
            const piece = board[row][col];
            if (!piece) {
                logDebug(`错误：位置 (${row}, ${col}) 没有棋子`);
                return [];
            }
            
            const moves = [];
            const color = piece.color;
            
            switch (piece.type) {
                case PIECE_TYPES.KING: // 将/帅
                    // 只能走一步，九宫格内
                    const kingMoves = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of kingMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        // 检查是否在九宫格内
                        let inPalace = false;
                        if (color === 'red') {
                            // 红方九宫格：行7-9，列3-5
                            inPalace = (newRow >= 7 && newRow <= 9 && newCol >= 3 && newCol <= 5);
                        } else {
                            // 黑方九宫格：行0-2，列3-5
                            inPalace = (newRow >= 0 && newRow <= 2 && newCol >= 3 && newCol <= 5);
                        }
                        
                        if (inPalace && isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.GUARD: // 士/仕
                    // 走斜线，一步，九宫格内
                    const guardMoves = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    for (const [dr, dc] of guardMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        // 检查是否在九宫格内
                        let inPalace = false;
                        if (color === 'red') {
                            inPalace = (newRow >= 7 && newRow <= 9 && newCol >= 3 && newCol <= 5);
                        } else {
                            inPalace = (newRow >= 0 && newRow <= 2 && newCol >= 3 && newCol <= 5);
                        }
                        
                        if (inPalace && isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.ELEPHANT: // 象/相
                    // 走田字，不能过河
                    const elephantMoves = [[-2, -2], [-2, 2], [2, -2], [2, 2]];
                    for (const [dr, dc] of elephantMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        const blockRow = row + dr / 2;
                        const blockCol = col + dc / 2;
                        
                        // 检查是否过河
                        let notCrossRiver = false;
                        if (color === 'red') {
                            notCrossRiver = newRow >= 5;  // 红象不能过河
                        } else {
                            notCrossRiver = newRow <= 4;  // 黑象不能过河
                        }
                        
                        if (notCrossRiver && isWithinBoard(newRow, newCol) && !board[blockRow][blockCol]) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.HORSE: // 马
                    // 走日字，有蹩马腿
                    const horseMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    for (const [dr, dc] of horseMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        // 检查蹩马腿
                        let blocked = false;
                        if (Math.abs(dr) === 2) { // 上下跳
                            const blockRow = row + dr/2;
                            if (isWithinBoard(blockRow, col) && board[blockRow][col]) {
                                blocked = true;
                            }
                        } else { // 左右跳
                            const blockCol = col + dc/2;
                            if (isWithinBoard(row, blockCol) && board[row][blockCol]) {
                                blocked = true;
                            }
                        }
                        
                        if (!blocked && isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.CHARIOT: // 车
                    // 走直线，不限步数，不能穿过其他棋子
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of directions) {
                        for (let i = 1; i < Math.max(ROWS, COLS); i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            
                            if (!isWithinBoard(newRow, newCol)) break;
                            
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece) {
                                moves.push({row: newRow, col: newCol});
                            } else {
                                if (targetPiece.color !== color) {
                                    moves.push({row: newRow, col: newCol});
                                }
                                break;
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.CANNON: // 炮
                    // 走直线，吃子需要隔一个棋子
                    for (const [dr, dc] of directions) {
                        let hasJumped = false;
                        for (let i = 1; i < Math.max(ROWS, COLS); i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            
                            if (!isWithinBoard(newRow, newCol)) break;
                            
                            const targetPiece = board[newRow][newCol];
                            if (!hasJumped) {
                                if (!targetPiece) {
                                    moves.push({row: newRow, col: newCol});
                                } else {
                                    hasJumped = true; // 遇到第一个棋子
                                }
                            } else {
                                if (targetPiece) {
                                    if (targetPiece.color !== color) {
                                        moves.push({row: newRow, col: newCol});
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.PAWN: // 兵/卒
                    // 红兵向下走，黑卒向上走
                    const forwardDir = color === 'red' ? -1 : 1;
                    const pawnMoves = [[forwardDir, 0]];
                    
                    // 过河后可以左右走
                    const isCrossedRiver = color === 'red' ? row <= 4 : row >= 5;
                    if (isCrossedRiver) {
                        pawnMoves.push([0, -1], [0, 1]);
                    }
                    
                    for (const [dr, dc] of pawnMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        if (isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
            }
            
            return moves;
        }
        
        // 检查坐标是否在棋盘内 - 修复：使用正确的行列数
        function isWithinBoard(row, col) {
            return row >= 0 && row < ROWS && col >= 0 && col < COLS;
        }
        
        // 更新状态栏
        function updateStatus() {
            const statusElement = document.getElementById('status');
            let statusText = '';
            
            if (!gameState.gameStarted) {
                statusText = '请选择游戏模式并点击"开始游戏"';
            } else if (gameState.aiThinking) {
                statusText = '电脑思考中...';
            } else {
                const playerName = gameState.currentPlayer === 'red' ? '红方' : '黑方';
                const modeText = gameState.gameMode === 'two-player' ? '双人对决' : '人机对决';
                const difficultyText = gameState.gameMode === 'ai' ? ` (${gameState.difficulty}难度)` : '';
                
                statusText = `${modeText}${difficultyText} - ${playerName}走棋`;
            }
            
            statusElement.textContent = statusText;
            
            // 检查游戏是否结束
            if (gameState.gameStarted) {
                const winner = checkWinner();
                if (winner) {
                    statusElement.textContent = winner === 'red' ? '游戏结束！红方获胜！' : '游戏结束！黑方获胜！';
                    gameState.gameStarted = false;
                }
            }
        }
        
        // 检查是否有胜利者
        function checkWinner() {
            let redKingFound = false;
            let blackKingFound = false;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.type === PIECE_TYPES.KING) {
                        if (piece.color === 'red') {
                            redKingFound = true;
                        } else {
                            blackKingFound = true;
                        }
                    }
                }
            }
            
            if (!redKingFound) return 'black';
            if (!blackKingFound) return 'red';
            return null;
        }
        
        // 移动棋子
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            
            // 保存移动历史用于悔棋
            gameState.moveHistory.push({
                fromRow, fromCol, toRow, toCol,
                capturedPiece: gameState.board[toRow][toCol]
            });
            
            // 移动棋子
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            // 切换玩家
            gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'black' : 'red';
            gameState.selectedPiece = null;
            
            // 重新绘制棋盘
            drawBoard();
            updateStatus();
            
            // 添加调试信息
            logDebug(`移动棋子: ${piece.type} (${piece.color}) 从 (${fromRow}, ${fromCol}) 到 (${toRow}, ${toCol})`);
            
            // 如果是人机模式且轮到电脑走棋
            if (gameState.gameMode === 'ai' && gameState.currentPlayer === 'black' && gameState.gameStarted) {
                setTimeout(makeAIMove, 500);
            }
        }
        
        // 事件处理 - 修复：正确计算点击位置
        function setupEventListeners() {
            const canvas = document.getElementById('chessboard');
            
            // 棋盘点击事件 - 修复：正确计算行列
            canvas.addEventListener('click', (e) => {
                if (!gameState.gameStarted || gameState.aiThinking) {
                    logDebug('游戏未开始或电脑正在思考');
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // 计算点击的行列
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);
                
                logDebug(`点击位置: 像素(${x}, ${y}), 行列(${row}, ${col})`);
                
                if (!isWithinBoard(row, col)) {
                    logDebug('点击位置不在棋盘内');
                    return;
                }
                
                // 如果已经有选中的棋子
                if (gameState.selectedPiece) {
                    const {row: selectedRow, col: selectedCol} = gameState.selectedPiece;
                    const piece = gameState.board[selectedRow][selectedCol];
                    
                    // 检查是否是当前玩家的棋子
                    if (piece.color !== gameState.currentPlayer) {
                        logDebug('不能移动对方的棋子');
                        gameState.selectedPiece = null;
                        drawBoard();
                        return;
                    }
                    
                    // 检查是否点击了自己的棋子（重新选择）
                    const clickedPiece = gameState.board[row][col];
                    if (clickedPiece && clickedPiece.color === gameState.currentPlayer) {
                        logDebug('重新选择棋子');
                        gameState.selectedPiece = {row, col};
                        drawBoard();
                        return;
                    }
                    
                    // 检查移动是否合法
                    const validMoves = getValidMoves(selectedRow, selectedCol, gameState.board);
                    const isValidMove = validMoves.some(move => move.row === row && move.col === col);
                    
                    if (isValidMove) {
                        logDebug('移动有效，执行移动');
                        movePiece(selectedRow, selectedCol, row, col);
                    } else {
                        logDebug('移动无效');
                        gameState.selectedPiece = null;
                        drawBoard();
                    }
                } else {
                    // 如果没有选中的棋子，选择棋子
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === gameState.currentPlayer) {
                        logDebug(`选择棋子: ${piece.type} (${piece.color})`);
                        gameState.selectedPiece = {row, col};
                        drawBoard();
                    } else {
                        logDebug(`没有选择棋子: 该位置${piece ? '是对方棋子' : '没有棋子'}`);
                    }
                }
            });
            
            // 游戏模式选择
            document.getElementById('two-player-mode').addEventListener('click', () => {
                setGameMode('two-player');
            });
            
            document.getElementById('ai-mode').addEventListener('click', () => {
                setGameMode('ai');
            });
            
            // 难度选择
            document.getElementById('easy').addEventListener('click', () => {
                setDifficulty('easy');
            });
            
            document.getElementById('medium').addEventListener('click', () => {
                setDifficulty('medium');
            });
            
            document.getElementById('hard').addEventListener('click', () => {
                setDifficulty('hard');
            });
            
            // 游戏控制
            document.getElementById('start-game').addEventListener('click', startGame);
            document.getElementById('reset-game').addEventListener('click', resetGame);
            document.getElementById('undo-move').addEventListener('click', undoMove);
            
            // 调试按钮
            document.getElementById('debug-toggle').addEventListener('click', () => {
                const debugInfo = document.getElementById('debug-info');
                if (debugInfo.style.display === 'none' || debugInfo.style.display === '') {
                    debugInfo.style.display = 'block';
                    document.getElementById('debug-toggle').textContent = '隐藏调试信息';
                } else {
                    debugInfo.style.display = 'none';
                    document.getElementById('debug-toggle').textContent = '显示调试信息';
                }
            });
        }
        
        // 调试日志函数
        function logDebug(message) {
            const debugInfo = document.getElementById('debug-info');
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.innerHTML = `[${timestamp}] ${message}<br>` + debugInfo.innerHTML;
        }
        
        // 设置游戏模式
        function setGameMode(mode) {
            gameState.gameMode = mode;
            
            // 更新按钮状态
            document.getElementById('two-player-mode').classList.toggle('active', mode === 'two-player');
            document.getElementById('ai-mode').classList.toggle('active', mode === 'ai');
            
            // 显示/隐藏难度选择
            const difficultySection = document.getElementById('difficulty-section');
            difficultySection.style.display = mode === 'ai' ? 'block' : 'none';
            
            updateStatus();
            logDebug(`游戏模式设置为: ${mode}`);
        }
        
        // 设置难度
        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            
            // 更新按钮状态
            document.getElementById('easy').classList.toggle('active', difficulty === 'easy');
            document.getElementById('medium').classList.toggle('active', difficulty === 'medium');
            document.getElementById('hard').classList.toggle('active', difficulty === 'hard');
            
            logDebug(`难度设置为: ${difficulty}`);
        }
        
        // 开始游戏
        function startGame() {
            if (!gameState.gameMode) {
                alert('请先选择游戏模式！');
                return;
            }
            
            if (gameState.gameMode === 'ai' && !gameState.difficulty) {
                alert('请选择游戏难度！');
                return;
            }
            
            gameState.gameStarted = true;
            updateStatus();
            logDebug('游戏开始！');
            
            // 如果人机模式且电脑先走（黑方），则让电脑走棋
            if (gameState.gameMode === 'ai' && gameState.currentPlayer === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }
        
        // 重置游戏
        function resetGame() {
            initBoard();
            drawBoard();
            gameState.gameStarted = false;
            updateStatus();
            logDebug('游戏重置！');
        }
        
        // 悔棋
        function undoMove() {
            if (gameState.moveHistory.length === 0 || gameState.aiThinking) {
                logDebug('无法悔棋');
                return;
            }
            
            const lastMove = gameState.moveHistory.pop();
            
            // 恢复棋子
            gameState.board[lastMove.fromRow][lastMove.fromCol] = gameState.board[lastMove.toRow][lastMove.toCol];
            gameState.board[lastMove.toRow][lastMove.toCol] = lastMove.capturedPiece;
            
            // 切换回上一个玩家
            gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'black' : 'red';
            gameState.selectedPiece = null;
            
            drawBoard();
            updateStatus();
            logDebug(`悔棋: 从(${lastMove.toRow}, ${lastMove.toCol})回到(${lastMove.fromRow}, ${lastMove.fromCol})`);
        }
        
        // AI走棋（简化版）
        function makeAIMove() {
            if (!gameState.gameStarted || gameState.currentPlayer !== 'black' || gameState.gameMode !== 'ai') {
                return;
            }
            
            gameState.aiThinking = true;
            updateStatus();
            logDebug('AI开始思考...');
            
            // 根据难度设置AI思考时间
            const thinkTime = gameState.difficulty === 'easy' ? 1000 : 
                             gameState.difficulty === 'medium' ? 700 : 300;
            
            setTimeout(() => {
                // 获取所有可能的走法
                const moves = [];
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const piece = gameState.board[row][col];
                        if (piece && piece.color === 'black') {
                            const pieceMoves = getValidMoves(row, col, gameState.board);
                            for (const move of pieceMoves) {
                                moves.push({
                                    fromRow: row,
                                    fromCol: col,
                                    toRow: move.row,
                                    toCol: move.col
                                });
                            }
                        }
                    }
                }
                
                if (moves.length === 0) {
                    gameState.aiThinking = false;
                    updateStatus();
                    return;
                }
                
                // 随机选择一个走法
                const chosenMove = moves[Math.floor(Math.random() * moves.length)];
                
                // 执行AI走棋
                movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
                gameState.aiThinking = false;
                logDebug(`AI移动: 从(${chosenMove.fromRow}, ${chosenMove.fromCol})到(${chosenMove.toRow}, ${chosenMove.toCol})`);
            }, thinkTime);
        }
        
        // 初始化游戏
        function initGame() {
            initBoard();
            drawBoard();
            setupEventListeners();
            
            // 默认选择双人对决模式
            setGameMode('two-player');
            setDifficulty('medium');
            
            logDebug('游戏初始化完成！');
        }
        
        // 页面加载完成后初始化游戏
        window.addEventListener('load', initGame);
    </script>
</body>
</html>