<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>传统中国象棋 - 已修复棋子移动问题</title>
    <style>
        /* 样式保持不变 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
        }
        
        body {
            background-color: #f5f5dc;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        h1 {
            color: #8B4513;
            font-size: 2.8rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
            letter-spacing: 5px;
        }
        
        .subtitle {
            color: #654321;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1400px;
            width: 100%;
        }
        
        .game-section {
            flex: 1;
            min-width: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .control-section {
            flex-basis: 400px;
            background-color: #f9f3e9;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
            border: 2px solid #8B4513;
        }
        
        #chessboard {
            background-color: #EACDA9;
            border: 10px solid #8B4513;
            border-radius: 5px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.25);
        }
        
        .status-bar {
            background-color: #8B4513;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 1.3rem;
            text-align: center;
            width: 100%;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-panel {
            margin-bottom: 25px;
        }
        
        .mode-selection {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .mode-btn {
            padding: 15px;
            font-size: 1.2rem;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .mode-btn:hover {
            background-color: #A0522D;
            transform: translateY(-3px);
        }
        
        .mode-btn.active {
            background-color: #654321;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .difficulty-selection {
            margin-top: 20px;
            padding: 20px;
            background-color: #f0e6d6;
            border-radius: 10px;
            border: 1px solid #8B4513;
            display: none;
        }
        
        .difficulty-selection h3 {
            color: #654321;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .difficulty-options {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .difficulty-btn {
            flex: 1;
            padding: 12px;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .difficulty-btn:hover {
            background-color: #A0522D;
        }
        
        .difficulty-btn.active {
            background-color: #654321;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.3);
        }
        
        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }
        
        .control-btn {
            padding: 15px;
            font-size: 1.1rem;
            background-color: #2E8B57;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background-color: #3CB371;
            transform: translateY(-3px);
        }
        
        .control-btn.reset {
            background-color: #CD5C5C;
        }
        
        .control-btn.reset:hover {
            background-color: #DC143C;
        }
        
        .rules {
            margin-top: 30px;
            padding: 20px;
            background-color: #f0e6d6;
            border-radius: 10px;
            border: 1px solid #8B4513;
        }
        
        .rules h3 {
            color: #654321;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .rules ul {
            padding-left: 20px;
            color: #333;
        }
        
        .rules li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .piece-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #654321;
        }
        
        .red-turn, .black-turn {
            font-weight: bold;
        }
        
        .red-turn {
            color: #D22B2B;
        }
        
        .black-turn {
            color: #000;
        }
        
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-section {
                min-width: 100%;
            }
            
            .control-section {
                width: 100%;
                max-width: 700px;
            }
        }
        
        @media (max-width: 768px) {
            #chessboard {
                width: 95vw;
                height: 95vw;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
        
        .footer {
            margin-top: 30px;
            color: #654321;
            text-align: center;
            font-size: 0.9rem;
            padding: 20px;
            width: 100%;
        }
        
        .debug-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            font-size: 0.9rem;
            color: #666;
            display: none;
        }
        
        .debug-toggle {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #ddd;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        /* 开始画面样式 */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
        }
        
        .start-content {
            text-align: center;
            max-width: 800px;
            padding: 40px;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.9), rgba(101, 67, 33, 0.9));
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 5px solid #FFD700;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5); }
            50% { transform: scale(1.02); box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7); }
            100% { transform: scale(1); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5); }
        }
        
        .start-title {
            font-size: 5rem;
            color: #FFD700;
            text-shadow: 0 0 20px #FFD700, 0 0 40px #FFA500;
            margin-bottom: 20px;
            letter-spacing: 10px;
        }
        
        .start-subtitle {
            font-size: 1.8rem;
            color: #FFF;
            margin-bottom: 40px;
            opacity: 0.9;
        }
        
        .start-instruction {
            font-size: 2.5rem;
            color: #FFD700;
            margin-bottom: 20px;
            animation: blink 1.5s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .start-hint {
            font-size: 1.5rem;
            color: #CCC;
            margin-bottom: 30px;
        }
        
        .start-btn {
            padding: 20px 50px;
            font-size: 1.8rem;
            background-color: #2E8B57;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .start-btn:hover {
            background-color: #3CB371;
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
        }
        
        .start-btn:active {
            transform: translateY(0);
        }
        
        @media (max-width: 768px) {
            .start-title {
                font-size: 3rem;
                letter-spacing: 5px;
            }
            
            .start-subtitle {
                font-size: 1.2rem;
            }
            
            .start-instruction {
                font-size: 1.8rem;
            }
            
            .start-hint {
                font-size: 1.2rem;
            }
            
            .start-btn {
                padding: 15px 30px;
                font-size: 1.5rem;
            }
        }
        
        /* 游戏结束画面样式 */
        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            color: white;
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
        }
        
        .game-over-content {
            text-align: center;
            max-width: 800px;
            padding: 50px;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.95), rgba(101, 67, 33, 0.95));
            border-radius: 25px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7);
            border: 5px solid #FF6B6B;
            animation: fadeIn 0.8s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .game-over-title {
            font-size: 4.5rem;
            color: #FF6B6B;
            text-shadow: 0 0 25px #FF6B6B, 0 0 50px #FF0000;
            margin-bottom: 20px;
            letter-spacing: 8px;
        }
        
        .game-over-result {
            font-size: 3rem;
            color: #FFD700;
            margin-bottom: 30px;
            text-shadow: 0 0 15px #FFD700;
        }
        
        .game-over-score {
            font-size: 2.5rem;
            color: #FFF;
            margin-bottom: 40px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px 30px;
            border-radius: 15px;
            display: inline-block;
            border: 2px solid #2E8B57;
        }
        
        .game-over-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 40px;
            font-size: 1.8rem;
        }
        
        .stat-item {
            background-color: rgba(0, 0, 0, 0.4);
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #4A90E2;
            min-width: 150px;
        }
        
        .stat-item span {
            color: #FFD700;
            font-weight: bold;
            font-size: 2.2rem;
        }
        
        .play-again-btn {
            padding: 20px 60px;
            font-size: 2rem;
            background-color: #2E8B57;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
        }
        
        .play-again-btn:hover {
            background-color: #3CB371;
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        .play-again-btn:active {
            transform: translateY(0);
        }
        
        .game-over-hint {
            font-size: 1.5rem;
            color: #CCC;
            opacity: 0.8;
        }
        
        @media (max-width: 768px) {
            .game-over-title {
                font-size: 3rem;
                letter-spacing: 5px;
            }
            
            .game-over-result {
                font-size: 2rem;
            }
            
            .game-over-score {
                font-size: 1.8rem;
            }
            
            .game-over-stats {
                flex-direction: column;
                gap: 20px;
                font-size: 1.5rem;
            }
            
            .stat-item {
                min-width: auto;
                padding: 12px 20px;
            }
            
            .stat-item span {
                font-size: 1.8rem;
            }
            
            .play-again-btn {
                padding: 15px 40px;
                font-size: 1.8rem;
            }
            
            .game-over-hint {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- 开始画面 -->
    <div id="start-screen" class="start-screen">
        <div class="start-content">
            <h1 class="start-title">中國象棋</h1>
            <div class="start-subtitle">传统版 - 已修复棋子移动问题</div>
            <div class="start-instruction">按任意键开始游戏</div>
            <div class="start-hint">或点击下方按钮开始</div>
            <button id="start-screen-btn" class="start-btn">开始游戏</button>
        </div>
    </div>

    <!-- 游戏结束画面 -->
    <div id="game-over-screen" class="game-over-screen">
        <div class="game-over-content">
            <h1 class="game-over-title">Game Over</h1>
            <div class="game-over-result" id="game-over-result">红方获胜！</div>
            <div class="game-over-score" id="game-over-score">分数: 0</div>
            <div class="game-over-stats">
                <div class="stat-item">胜场: <span id="wins-count">0</span></div>
                <div class="stat-item">负场: <span id="losses-count">0</span></div>
                <div class="stat-item">和棋: <span id="draws-count">0</span></div>
            </div>
            <button id="play-again-btn" class="play-again-btn">再玩一次</button>
            <div class="game-over-hint">或按任意键重新开始</div>
        </div>
    </div>

    <div class="header">
        <h1>中國象棋</h1>
        <div class="subtitle">传统版 - 已修复棋子移动问题</div>
    </div>
    
    <div class="container">
        <div class="game-section">
            <canvas id="chessboard" width="700" height="700"></canvas>
            <div class="status-bar" id="status">请选择游戏模式</div>
            <button class="debug-toggle" id="debug-toggle">显示调试信息</button>
            <div class="debug-info" id="debug-info">调试信息将显示在这里</div>
        </div>
        
        <div class="control-section">
            <div class="control-panel">
                <h2>游戏设置</h2>
                <div class="mode-selection">
                    <button class="mode-btn" id="two-player-mode">双人对决</button>
                    <button class="mode-btn" id="ai-mode">人机对决</button>
                </div>
                
                <div class="difficulty-selection" id="difficulty-section">
                    <h3>选择难度级别</h3>
                    <div class="difficulty-options">
                        <button class="difficulty-btn" id="easy">简单</button>
                        <button class="difficulty-btn" id="medium">中等</button>
                        <button class="difficulty-btn" id="hard">困难</button>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="control-btn" id="start-game">开始游戏</button>
                    <button class="control-btn reset" id="reset-game">重新开始</button>
                    <button class="control-btn" id="undo-move">悔棋一步</button>
                </div>
            </div>
            
            <div class="rules">
                <h3>操作说明</h3>
                <ul>
                    <li><strong>红方先走</strong>，点击自己的棋子选择</li>
                    <li>再次点击目标位置移动棋子</li>
                    <li>绿色圆点表示可以移动的位置</li>
                    <li>如果棋子无法移动，请检查：
                        <ul>
                            <li>是否轮到你走棋（看状态栏）</li>
                            <li>是否符合棋子移动规则</li>
                            <li>是否点击了正确的目标位置</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <div class="piece-info">
                <div class="red-turn">红方：将、士、象、马、车、炮、兵</div>
                <div class="black-turn">黑方：帅、仕、相、马、车、炮、卒</div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        传统中国象棋游戏 - 使用HTML5 Canvas开发 | 已修复棋子移动问题
    </div>

    <script>
        // 游戏状态
        const gameState = {
            board: [],
            currentPlayer: 'red', // 'red' 或 'black'
            gameMode: null, // 'two-player' 或 'ai'
            difficulty: 'medium', // 'easy', 'medium', 'hard'
            gameStarted: false,
            selectedPiece: null,
            moveHistory: [],
            aiThinking: false,
            originalBoard: null, // 保存初始棋盘状态
            showStartScreen: true, // 是否显示开始画面
            // 胜场累计系统
            stats: {
                wins: 0,    // 红方胜利次数
                losses: 0,  // 黑方胜利次数（红方失败）
                draws: 0    // 和棋次数
            },
            currentScore: 0 // 当前游戏分数
        };

        // 棋盘和棋子常量
        const ROWS = 10;
        const COLS = 9;
        const CELL_SIZE = 70;
        const PIECE_RADIUS = 30;
        
        // 棋子类型
        const PIECE_TYPES = {
            KING: '将',      // 将/帅
            GUARD: '士',     // 士/仕
            ELEPHANT: '象',  // 象/相
            HORSE: '马',     // 马
            CHARIOT: '车',   // 车
            CANNON: '炮',    // 炮
            PAWN: '兵'       // 兵/卒
        };
        
        // 初始化棋盘
        function initBoard() {
            // 创建空棋盘
            gameState.board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            
            // 放置黑方棋子
            gameState.board[0][0] = {type: PIECE_TYPES.CHARIOT, color: 'black'};
            gameState.board[0][1] = {type: PIECE_TYPES.HORSE, color: 'black'};
            gameState.board[0][2] = {type: PIECE_TYPES.ELEPHANT, color: 'black'};
            gameState.board[0][3] = {type: PIECE_TYPES.GUARD, color: 'black'};
            gameState.board[0][4] = {type: PIECE_TYPES.KING, color: 'black'};
            gameState.board[0][5] = {type: PIECE_TYPES.GUARD, color: 'black'};
            gameState.board[0][6] = {type: PIECE_TYPES.ELEPHANT, color: 'black'};
            gameState.board[0][7] = {type: PIECE_TYPES.HORSE, color: 'black'};
            gameState.board[0][8] = {type: PIECE_TYPES.CHARIOT, color: 'black'};
            gameState.board[2][1] = {type: PIECE_TYPES.CANNON, color: 'black'};
            gameState.board[2][7] = {type: PIECE_TYPES.CANNON, color: 'black'};
            gameState.board[3][0] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][2] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][4] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][6] = {type: PIECE_TYPES.PAWN, color: 'black'};
            gameState.board[3][8] = {type: PIECE_TYPES.PAWN, color: 'black'};
            
            // 放置红方棋子
            gameState.board[9][0] = {type: PIECE_TYPES.CHARIOT, color: 'red'};
            gameState.board[9][1] = {type: PIECE_TYPES.HORSE, color: 'red'};
            gameState.board[9][2] = {type: PIECE_TYPES.ELEPHANT, color: 'red'};
            gameState.board[9][3] = {type: PIECE_TYPES.GUARD, color: 'red'};
            gameState.board[9][4] = {type: PIECE_TYPES.KING, color: 'red'};
            gameState.board[9][5] = {type: PIECE_TYPES.GUARD, color: 'red'};
            gameState.board[9][6] = {type: PIECE_TYPES.ELEPHANT, color: 'red'};
            gameState.board[9][7] = {type: PIECE_TYPES.HORSE, color: 'red'};
            gameState.board[9][8] = {type: PIECE_TYPES.CHARIOT, color: 'red'};
            gameState.board[7][1] = {type: PIECE_TYPES.CANNON, color: 'red'};
            gameState.board[7][7] = {type: PIECE_TYPES.CANNON, color: 'red'};
            gameState.board[6][0] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][2] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][4] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][6] = {type: PIECE_TYPES.PAWN, color: 'red'};
            gameState.board[6][8] = {type: PIECE_TYPES.PAWN, color: 'red'};
            
            // 保存初始棋盘状态
            gameState.originalBoard = JSON.parse(JSON.stringify(gameState.board));
            
            // 重置游戏状态
            gameState.currentPlayer = 'red';
            gameState.selectedPiece = null;
            gameState.moveHistory = [];
            gameState.aiThinking = false;
            
            updateStatus();
            
            // 添加调试信息
            logDebug('棋盘初始化完成，红方先走');
        }
        
        // 恢复初始棋盘
        function restoreOriginalBoard() {
            gameState.board = JSON.parse(JSON.stringify(gameState.originalBoard));
            gameState.currentPlayer = 'red';
            gameState.selectedPiece = null;
            gameState.moveHistory = [];
            gameState.aiThinking = false;
            gameState.gameStarted = true;
            
            drawBoard();
            updateStatus();
            logDebug('恢复到初始棋盘状态');
            
            // 如果是人机模式，红方先走
            if (gameState.gameMode === 'ai') {
                logDebug('人机模式，红方先走');
            }
        }
        
        // 绘制棋盘
        function drawBoard() {
            const canvas = document.getElementById('chessboard');
            const ctx = canvas.getContext('2d');
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制棋盘背景
            ctx.fillStyle = '#EACDA9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制棋盘格子
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            
            // 绘制横线
            for (let i = 0; i < ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                ctx.lineTo(canvas.width - CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                ctx.stroke();
            }
            
            // 绘制竖线
            for (let i = 0; i < COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 2);
                ctx.lineTo(i * CELL_SIZE + CELL_SIZE / 2, canvas.height - CELL_SIZE / 2);
                ctx.stroke();
            }
            
            // 绘制九宫格
            ctx.lineWidth = 2;
            ctx.beginPath();
            // 上九宫格（黑方）
            ctx.moveTo(3 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(5 * CELL_SIZE + CELL_SIZE / 2, 2 * CELL_SIZE + CELL_SIZE / 2);
            ctx.moveTo(5 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(3 * CELL_SIZE + CELL_SIZE / 2, 2 * CELL_SIZE + CELL_SIZE / 2);
            // 下九宫格（红方）
            ctx.moveTo(3 * CELL_SIZE + CELL_SIZE / 2, 7 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(5 * CELL_SIZE + CELL_SIZE / 2, 9 * CELL_SIZE + CELL_SIZE / 2);
            ctx.moveTo(5 * CELL_SIZE + CELL_SIZE / 2, 7 * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(3 * CELL_SIZE + CELL_SIZE / 2, 9 * CELL_SIZE + CELL_SIZE / 2);
            ctx.stroke();
            
            // 绘制棋子
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        drawPiece(ctx, col, row, piece);
                    }
                }
            }
            
            // 绘制选中的棋子
            if (gameState.selectedPiece) {
                const {row, col} = gameState.selectedPiece;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                    col * CELL_SIZE + CELL_SIZE / 2,
                    row * CELL_SIZE + CELL_SIZE / 2,
                    PIECE_RADIUS + 5,
                    0,
                    Math.PI * 2
                );
                ctx.stroke();
                
                // 绘制可移动位置
                const moves = getValidMoves(row, col, gameState.board);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                for (const move of moves) {
                    ctx.beginPath();
                    ctx.arc(
                        move.col * CELL_SIZE + CELL_SIZE / 2,
                        move.row * CELL_SIZE + CELL_SIZE / 2,
                        8,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // 调试信息
                logDebug(`选中棋子: ${gameState.board[row][col].type} (${gameState.board[row][col].color}) 在位置 (${row}, ${col})`);
                logDebug(`可移动位置: ${moves.length} 个`);
            }
            
            // 绘制楚河汉界
            ctx.fillStyle = '#000';
            ctx.font = 'bold 30px SimHei';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('楚河', 4.5 * CELL_SIZE, 4.8 * CELL_SIZE);
            ctx.fillText('汉界', 4.5 * CELL_SIZE, 5.2 * CELL_SIZE);
        }
        
        // 绘制棋子
        function drawPiece(ctx, col, row, piece) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            
            // 绘制棋子背景
            const gradient = ctx.createRadialGradient(x, y, 5, x, y, PIECE_RADIUS);
            if (piece.color === 'red') {
                gradient.addColorStop(0, '#FF6B6B');
                gradient.addColorStop(1, '#D22B2B');
            } else {
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(1, '#000');
            }
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, PIECE_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制棋子边框
            ctx.strokeStyle = piece.color === 'red' ? '#8B0000' : '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制棋子文字
            ctx.fillStyle = piece.color === 'red' ? '#FFD700' : '#FFF';
            ctx.font = 'bold 28px SimHei';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(piece.type, x, y);
        }
        
        // 获取棋子的合法移动
        function getValidMoves(row, col, board) {
            const piece = board[row][col];
            if (!piece) {
                return [];
            }
            
            const moves = [];
            const color = piece.color;
            
            // 定义四个基本方向
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            switch (piece.type) {
                case PIECE_TYPES.KING: // 将/帅
                    const kingMoves = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of kingMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        // 检查是否在九宫格内
                        let inPalace = false;
                        if (color === 'red') {
                            inPalace = (newRow >= 7 && newRow <= 9 && newCol >= 3 && newCol <= 5);
                        } else {
                            inPalace = (newRow >= 0 && newRow <= 2 && newCol >= 3 && newCol <= 5);
                        }
                        
                        if (inPalace && isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.GUARD: // 士/仕
                    const guardMoves = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    for (const [dr, dc] of guardMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        // 检查是否在九宫格内
                        let inPalace = false;
                        if (color === 'red') {
                            inPalace = (newRow >= 7 && newRow <= 9 && newCol >= 3 && newCol <= 5);
                        } else {
                            inPalace = (newRow >= 0 && newRow <= 2 && newCol >= 3 && newCol <= 5);
                        }
                        
                        if (inPalace && isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.ELEPHANT: // 象/相
                    const elephantMoves = [[-2, -2], [-2, 2], [2, -2], [2, 2]];
                    for (const [dr, dc] of elephantMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        const blockRow = row + dr / 2;
                        const blockCol = col + dc / 2;
                        
                        // 检查是否过河
                        let notCrossRiver = false;
                        if (color === 'red') {
                            notCrossRiver = newRow >= 5;  // 红象不能过河
                        } else {
                            notCrossRiver = newRow <= 4;  // 黑象不能过河
                        }
                        
                        if (notCrossRiver && isWithinBoard(newRow, newCol) && isWithinBoard(blockRow, blockCol) && !board[blockRow][blockCol]) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.HORSE: // 马
                    const horseMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    for (const [dr, dc] of horseMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        // 检查蹩马腿
                        let blocked = false;
                        if (Math.abs(dr) === 2) { // 上下跳
                            const blockRow = row + dr/2;
                            if (isWithinBoard(blockRow, col) && board[blockRow][col]) {
                                blocked = true;
                            }
                        } else { // 左右跳
                            const blockCol = col + dc/2;
                            if (isWithinBoard(row, blockCol) && board[row][blockCol]) {
                                blocked = true;
                            }
                        }
                        
                        if (!blocked && isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.CHARIOT: // 车
                    for (const [dr, dc] of directions) {
                        for (let i = 1; i < Math.max(ROWS, COLS); i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            
                            if (!isWithinBoard(newRow, newCol)) break;
                            
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece) {
                                moves.push({row: newRow, col: newCol});
                            } else {
                                if (targetPiece.color !== color) {
                                    moves.push({row: newRow, col: newCol});
                                }
                                break;
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.CANNON: // 炮
                    for (const [dr, dc] of directions) {
                        let hasJumped = false;
                        for (let i = 1; i < Math.max(ROWS, COLS); i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            
                            if (!isWithinBoard(newRow, newCol)) break;
                            
                            const targetPiece = board[newRow][newCol];
                            if (!hasJumped) {
                                if (!targetPiece) {
                                    moves.push({row: newRow, col: newCol});
                                } else {
                                    hasJumped = true; // 遇到第一个棋子
                                }
                            } else {
                                if (targetPiece) {
                                    if (targetPiece.color !== color) {
                                        moves.push({row: newRow, col: newCol});
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    break;
                    
                case PIECE_TYPES.PAWN: // 兵/卒
                    const forwardDir = color === 'red' ? -1 : 1;
                    const pawnMoves = [[forwardDir, 0]];
                    
                    // 过河后可以左右走
                    const isCrossedRiver = color === 'red' ? row <= 4 : row >= 5;
                    if (isCrossedRiver) {
                        pawnMoves.push([0, -1], [0, 1]);
                    }
                    
                    for (const [dr, dc] of pawnMoves) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        if (isWithinBoard(newRow, newCol)) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                    break;
            }
            
            return moves;
        }
        
        // 检查坐标是否在棋盘内
        function isWithinBoard(row, col) {
            return row >= 0 && row < ROWS && col >= 0 && col < COLS;
        }
        
        // 更新状态栏
        function updateStatus() {
            const statusElement = document.getElementById('status');
            let statusText = '';
            
            if (!gameState.gameStarted) {
                statusText = '请选择游戏模式并点击"开始游戏"';
            } else if (gameState.aiThinking) {
                statusText = '电脑思考中...';
            } else {
                const playerName = gameState.currentPlayer === 'red' ? '红方' : '黑方';
                const modeText = gameState.gameMode === 'two-player' ? '双人对决' : '人机对决';
                const difficultyText = gameState.gameMode === 'ai' ? ` (${gameState.difficulty}难度)` : '';
                
                statusText = `${modeText}${difficultyText} - ${playerName}走棋`;
            }
            
            statusElement.textContent = statusText;
            
            // 检查游戏是否结束
            if (gameState.gameStarted) {
                const winner = checkWinner();
                if (winner) {
                    statusElement.textContent = winner === 'red' ? '游戏结束！红方获胜！' : '游戏结束！黑方获胜！';
                    gameState.gameStarted = false;
                    
                    // 显示游戏结束画面
                    setTimeout(() => {
                        showGameOverScreen(winner);
                    }, 500); // 延迟500ms显示，让用户看到状态栏变化
                }
            }
        }
        
        // 检查是否有胜利者
        function checkWinner() {
            let redKingFound = false;
            let blackKingFound = false;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.type === PIECE_TYPES.KING) {
                        if (piece.color === 'red') {
                            redKingFound = true;
                        } else {
                            blackKingFound = true;
                        }
                    }
                }
            }
            
            if (!redKingFound) return 'black';
            if (!blackKingFound) return 'red';
            return null;
        }
        
        // 显示游戏结束画面
        function showGameOverScreen(winner) {
            // 更新统计
            if (winner === 'red') {
                gameState.stats.wins++;
                gameState.currentScore += 100; // 胜利加100分
            } else if (winner === 'black') {
                gameState.stats.losses++;
                gameState.currentScore += 50; // 失败加50分
            } else {
                gameState.stats.draws++;
                gameState.currentScore += 75; // 和棋加75分
            }
            
            // 保存统计到localStorage
            saveStats();
            
            // 更新游戏结束画面内容
            const resultElement = document.getElementById('game-over-result');
            const scoreElement = document.getElementById('game-over-score');
            const winsElement = document.getElementById('wins-count');
            const lossesElement = document.getElementById('losses-count');
            const drawsElement = document.getElementById('draws-count');
            
            if (winner === 'red') {
                resultElement.textContent = '红方获胜！';
                resultElement.style.color = '#FF6B6B';
            } else if (winner === 'black') {
                resultElement.textContent = '黑方获胜！';
                resultElement.style.color = '#4A90E2';
            } else {
                resultElement.textContent = '和棋！';
                resultElement.style.color = '#FFD700';
            }
            
            scoreElement.textContent = `分数: ${gameState.currentScore}`;
            winsElement.textContent = gameState.stats.wins;
            lossesElement.textContent = gameState.stats.losses;
            drawsElement.textContent = gameState.stats.draws;
            
            // 显示游戏结束画面
            const gameOverScreen = document.getElementById('game-over-screen');
            gameOverScreen.style.display = 'flex';
            
            // 添加键盘事件监听器（按任意键重新开始）
            const keyHandler = (e) => {
                if (e.key !== 'Escape') { // 排除Esc键
                    playAgain();
                    document.removeEventListener('keydown', keyHandler);
                }
            };
            document.addEventListener('keydown', keyHandler);
            
            logDebug(`游戏结束！${winner === 'red' ? '红方' : winner === 'black' ? '黑方' : '和棋'}获胜`);
        }
        
        // 再玩一次
        function playAgain() {
            // 隐藏游戏结束画面
            const gameOverScreen = document.getElementById('game-over-screen');
            gameOverScreen.style.display = 'none';
            
            // 重置游戏
            resetGame();
        }
        
        // 保存统计到localStorage
        function saveStats() {
            try {
                localStorage.setItem('chessStats', JSON.stringify(gameState.stats));
                localStorage.setItem('chessScore', gameState.currentScore.toString());
            } catch (e) {
                logDebug('保存统计失败: ' + e);
            }
        }
        
        // 加载统计从localStorage
        function loadStats() {
            try {
                const stats = localStorage.getItem('chessStats');
                const score = localStorage.getItem('chessScore');
                
                if (stats) {
                    gameState.stats = JSON.parse(stats);
                }
                if (score) {
                    gameState.currentScore = parseInt(score) || 0;
                }
            } catch (e) {
                logDebug('加载统计失败: ' + e);
            }
        }
        
        // 移动棋子
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            
            // 保存移动历史用于悔棋
            gameState.moveHistory.push({
                fromRow, fromCol, toRow, toCol,
                capturedPiece: gameState.board[toRow][toCol]
            });
            
            // 移动棋子
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            // 切换玩家
            gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'black' : 'red';
            gameState.selectedPiece = null;
            
            // 重新绘制棋盘
            drawBoard();
            updateStatus();
            
            // 添加调试信息
            logDebug(`移动棋子: ${piece.type} (${piece.color}) 从 (${fromRow}, ${fromCol}) 到 (${toRow}, ${toCol})`);
            
            // 如果是人机模式且轮到电脑走棋
            if (gameState.gameMode === 'ai' && gameState.currentPlayer === 'black' && gameState.gameStarted) {
                // 延迟一点时间让用户看到自己的移动
                setTimeout(makeAIMove, 100);
            }
        }
        
        // 事件处理
        function setupEventListeners() {
            const canvas = document.getElementById('chessboard');
            
            // 键盘事件 - 按任意键开始游戏
            document.addEventListener('keydown', (e) => {
                if (gameState.showStartScreen && !gameState.gameStarted) {
                    // 按任意键开始游戏
                    startGame();
                }
            });
            
            // 开始画面按钮事件
            document.getElementById('start-screen-btn').addEventListener('click', () => {
                if (gameState.showStartScreen && !gameState.gameStarted) {
                    startGame();
                }
            });
            
            // 棋盘点击事件
            canvas.addEventListener('click', (e) => {
                if (!gameState.gameStarted || gameState.aiThinking) {
                    logDebug('游戏未开始或电脑正在思考');
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // 计算点击的行列
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);
                
                logDebug(`点击位置: 像素(${x}, ${y}), 行列(${row}, ${col})`);
                
                if (!isWithinBoard(row, col)) {
                    logDebug('点击位置不在棋盘内');
                    return;
                }
                
                // 如果已经有选中的棋子
                if (gameState.selectedPiece) {
                    const {row: selectedRow, col: selectedCol} = gameState.selectedPiece;
                    const piece = gameState.board[selectedRow][selectedCol];
                    
                    // 检查是否是当前玩家的棋子
                    if (piece.color !== gameState.currentPlayer) {
                        logDebug('不能移动对方的棋子');
                        gameState.selectedPiece = null;
                        drawBoard();
                        return;
                    }
                    
                    // 检查是否点击了自己的棋子（重新选择）
                    const clickedPiece = gameState.board[row][col];
                    if (clickedPiece && clickedPiece.color === gameState.currentPlayer) {
                        logDebug('重新选择棋子');
                        gameState.selectedPiece = {row, col};
                        drawBoard();
                        return;
                    }
                    
                    // 检查移动是否合法
                    const validMoves = getValidMoves(selectedRow, selectedCol, gameState.board);
                    const isValidMove = validMoves.some(move => move.row === row && move.col === col);
                    
                    if (isValidMove) {
                        logDebug('移动有效，执行移动');
                        movePiece(selectedRow, selectedCol, row, col);
                    } else {
                        logDebug('移动无效');
                        gameState.selectedPiece = null;
                        drawBoard();
                    }
                } else {
                    // 如果没有选中的棋子，选择棋子
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === gameState.currentPlayer) {
                        logDebug(`选择棋子: ${piece.type} (${piece.color})`);
                        gameState.selectedPiece = {row, col};
                        drawBoard();
                    } else {
                        logDebug(`没有选择棋子: 该位置${piece ? '是对方棋子' : '没有棋子'}`);
                    }
                }
            });
            
            // 游戏模式选择
            document.getElementById('two-player-mode').addEventListener('click', () => {
                setGameMode('two-player');
            });
            
            document.getElementById('ai-mode').addEventListener('click', () => {
                setGameMode('ai');
            });
            
            // 难度选择
            document.getElementById('easy').addEventListener('click', () => {
                setDifficulty('easy');
            });
            
            document.getElementById('medium').addEventListener('click', () => {
                setDifficulty('medium');
            });
            
            document.getElementById('hard').addEventListener('click', () => {
                setDifficulty('hard');
            });
            
            // 游戏控制
            document.getElementById('start-game').addEventListener('click', startGame);
            document.getElementById('reset-game').addEventListener('click', resetGame);
            document.getElementById('undo-move').addEventListener('click', undoMove);
            
            // 调试按钮
            document.getElementById('debug-toggle').addEventListener('click', () => {
                const debugInfo = document.getElementById('debug-info');
                if (debugInfo.style.display === 'none' || debugInfo.style.display === '') {
                    debugInfo.style.display = 'block';
                    document.getElementById('debug-toggle').textContent = '隐藏调试信息';
                } else {
                    debugInfo.style.display = 'none';
                    document.getElementById('debug-toggle').textContent = '显示调试信息';
                }
            });
        }
        
        // 调试日志函数
        function logDebug(message) {
            const debugInfo = document.getElementById('debug-info');
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.innerHTML = `[${timestamp}] ${message}<br>` + debugInfo.innerHTML;
        }
        
        // 设置游戏模式
        function setGameMode(mode) {
            const oldMode = gameState.gameMode;
            gameState.gameMode = mode;
            
            // 更新按钮状态
            document.getElementById('two-player-mode').classList.toggle('active', mode === 'two-player');
            document.getElementById('ai-mode').classList.toggle('active', mode === 'ai');
            
            // 显示/隐藏难度选择
            const difficultySection = document.getElementById('difficulty-section');
            difficultySection.style.display = mode === 'ai' ? 'block' : 'none';
            
            // 如果从双人模式切换到人机模式，自动恢复到初始棋盘
            if (oldMode === 'two-player' && mode === 'ai') {
                if (confirm('切换到人机模式将重置游戏到初始状态，是否继续？')) {
                    restoreOriginalBoard();
                } else {
                    // 如果用户取消，恢复原来的模式
                    gameState.gameMode = oldMode;
                    document.getElementById('two-player-mode').classList.toggle('active', oldMode === 'two-player');
                    document.getElementById('ai-mode').classList.toggle('active', oldMode === 'ai');
                    difficultySection.style.display = oldMode === 'ai' ? 'block' : 'none';
                    return;
                }
            }
            
            // 如果游戏已经开始了，更新状态
            if (gameState.gameStarted) {
                updateStatus();
            }
            
            logDebug(`游戏模式设置为: ${mode}`);
        }
        
        // 设置难度
        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            
            // 更新按钮状态
            document.getElementById('easy').classList.toggle('active', difficulty === 'easy');
            document.getElementById('medium').classList.toggle('active', difficulty === 'medium');
            document.getElementById('hard').classList.toggle('active', difficulty === 'hard');
            
            logDebug(`难度设置为: ${difficulty}`);
            
            // 如果是人机模式且游戏已经开始，立即重置游戏
            if (gameState.gameMode === 'ai' && gameState.gameStarted) {
                restoreOriginalBoard();
            }
        }
        
        // 开始游戏
        function startGame() {
            if (!gameState.gameMode) {
                alert('请先选择游戏模式！');
                return;
            }
            
            if (gameState.gameMode === 'ai' && !gameState.difficulty) {
                alert('请选择游戏难度！');
                return;
            }
            
            // 隐藏开始画面
            if (gameState.showStartScreen) {
                const startScreen = document.getElementById('start-screen');
                if (startScreen) {
                    startScreen.style.display = 'none';
                }
                gameState.showStartScreen = false;
            }
            
            gameState.gameStarted = true;
            updateStatus();
            logDebug('游戏开始！');
            
            // 如果人机模式且电脑先走（黑方），则让电脑走棋
            if (gameState.gameMode === 'ai' && gameState.currentPlayer === 'black') {
                // 给用户一点时间看到游戏开始
                setTimeout(makeAIMove, 300);
            }
        }
        
        // 重置游戏
        function resetGame() {
            initBoard();
            drawBoard();
            gameState.gameStarted = false;
            gameState.showStartScreen = true;
            
            // 显示开始画面
            const startScreen = document.getElementById('start-screen');
            if (startScreen) {
                startScreen.style.display = 'flex';
            }
            
            updateStatus();
            logDebug('游戏重置！');
        }
        
        // 悔棋
        function undoMove() {
            if (gameState.moveHistory.length === 0 || gameState.aiThinking) {
                logDebug('无法悔棋');
                return;
            }
            
            const lastMove = gameState.moveHistory.pop();
            
            // 恢复棋子
            gameState.board[lastMove.fromRow][lastMove.fromCol] = gameState.board[lastMove.toRow][lastMove.toCol];
            gameState.board[lastMove.toRow][lastMove.toCol] = lastMove.capturedPiece;
            
            // 切换回上一个玩家
            gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'black' : 'red';
            gameState.selectedPiece = null;
            
            drawBoard();
            updateStatus();
            logDebug(`悔棋: 从(${lastMove.toRow}, ${lastMove.toCol})回到(${lastMove.fromRow}, ${lastMove.fromCol})`);
        }
        
        // 优化的AI走棋函数 - 大幅减少思考时间
        function makeAIMove() {
            if (!gameState.gameStarted || gameState.currentPlayer !== 'black' || gameState.gameMode !== 'ai') {
                return;
            }
            
            gameState.aiThinking = true;
            updateStatus();
            logDebug('AI开始思考...');
            
            // 使用立即执行，几乎无延迟
            setTimeout(() => {
                try {
                    // 获取所有可能的走法
                    const moves = [];
                    for (let row = 0; row < ROWS; row++) {
                        for (let col = 0; col < COLS; col++) {
                            const piece = gameState.board[row][col];
                            if (piece && piece.color === 'black') {
                                const pieceMoves = getValidMoves(row, col, gameState.board);
                                for (const move of pieceMoves) {
                                    moves.push({
                                        fromRow: row,
                                        fromCol: col,
                                        toRow: move.row,
                                        toCol: move.col,
                                        pieceType: piece.type
                                    });
                                }
                            }
                        }
                    }
                    
                    if (moves.length === 0) {
                        gameState.aiThinking = false;
                        updateStatus();
                        return;
                    }
                    
                    // 根据难度选择走法 - 优化算法效率
                    let chosenMove;
                    
                    if (gameState.difficulty === 'easy') {
                        // 简单：随机走法，但优先吃子
                        const capturingMoves = moves.filter(move => gameState.board[move.toRow][move.toCol]);
                        if (capturingMoves.length > 0) {
                            chosenMove = capturingMoves[Math.floor(Math.random() * capturingMoves.length)];
                        } else {
                            chosenMove = moves[Math.floor(Math.random() * moves.length)];
                        }
                    } else if (gameState.difficulty === 'medium') {
                        // 中等：快速评估，优先吃子
                        const ratedMoves = moves.map(move => {
                            let score = 0;
                            const targetPiece = gameState.board[move.toRow][move.toCol];
                            
                            // 吃子得分
                            if (targetPiece) {
                                const pieceValue = {
                                    [PIECE_TYPES.KING]: 1000,
                                    [PIECE_TYPES.CHARIOT]: 9,
                                    [PIECE_TYPES.CANNON]: 7,
                                    [PIECE_TYPES.HORSE]: 6,
                                    [PIECE_TYPES.ELEPHANT]: 2,
                                    [PIECE_TYPES.GUARD]: 2,
                                    [PIECE_TYPES.PAWN]: 3
                                };
                                score += pieceValue[targetPiece.type] || 0;
                            }
                            
                            // 向前移动（对黑方来说是向下）得分
                            if (move.toRow > move.fromRow) score += 1;
                            
                            // 中心控制得分
                            if (move.toCol >= 3 && move.toCol <= 5) score += 1;
                            
                            return {move, score};
                        });
                        
                        // 快速排序并选择高分走法
                        ratedMoves.sort((a, b) => b.score - a.score);
                        const topMoves = ratedMoves.slice(0, Math.min(5, ratedMoves.length));
                        chosenMove = topMoves[Math.floor(Math.random() * topMoves.length)].move;
                    } else {
                        // 困难：稍微复杂的评估
                        const ratedMoves = moves.map(move => {
                            let score = 0;
                            const targetPiece = gameState.board[move.toRow][move.toCol];
                            
                            // 吃子得分
                            if (targetPiece) {
                                const pieceValue = {
                                    [PIECE_TYPES.KING]: 1000,
                                    [PIECE_TYPES.CHARIOT]: 9,
                                    [PIECE_TYPES.CANNON]: 7,
                                    [PIECE_TYPES.HORSE]: 6,
                                    [PIECE_TYPES.ELEPHANT]: 2,
                                    [PIECE_TYPES.GUARD]: 2,
                                    [PIECE_TYPES.PAWN]: 3
                                };
                                score += pieceValue[targetPiece.type] || 0;
                            }
                            
                            // 棋子价值（移动重要棋子）
                            const pieceValue = {
                                [PIECE_TYPES.KING]: 0,
                                [PIECE_TYPES.CHARIOT]: 1,
                                [PIECE_TYPES.CANNON]: 1,
                                [PIECE_TYPES.HORSE]: 2,
                                [PIECE_TYPES.ELEPHANT]: 0,
                                [PIECE_TYPES.GUARD]: 0,
                                [PIECE_TYPES.PAWN]: 3
                            };
                            score += pieceValue[move.pieceType] || 0;
                            
                            // 向前移动得分
                            if (move.toRow > move.fromRow) score += 2;
                            
                            // 中心控制得分
                            const centerDistance = Math.abs(move.toCol - 4);
                            score += (5 - centerDistance);
                            
                            // 攻击红方棋子得分
                            const targetRow = move.toRow - 1; // 上方位置
                            const targetCol = move.toCol;
                            if (isWithinBoard(targetRow, targetCol)) {
                                const threatPiece = gameState.board[targetRow][targetCol];
                                if (threatPiece && threatPiece.color === 'red') {
                                    score += 1;
                                }
                            }
                            
                            return {move, score};
                        });
                        
                        // 选择最佳走法
                        ratedMoves.sort((a, b) => b.score - a.score);
                        const bestScore = ratedMoves[0].score;
                        const bestMoves = ratedMoves.filter(m => m.score >= bestScore - 3);
                        chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
                    }
                    
                    // 立即执行AI走棋
                    movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
                    gameState.aiThinking = false;
                    logDebug(`AI移动: ${chosenMove.pieceType} 从(${chosenMove.fromRow}, ${chosenMove.fromCol})到(${chosenMove.toRow}, ${chosenMove.toCol})`);
                    
                } catch (error) {
                    logDebug(`AI移动出错: ${error}`);
                    gameState.aiThinking = false;
                    updateStatus();
                }
            }, 50); // 仅50ms延迟，几乎立即响应
        }
        
        // 初始化游戏
        function initGame() {
            // 加载统计信息
            loadStats();
            
            initBoard();
            drawBoard();
            setupEventListeners();
            
            // 默认选择双人对决模式
            setGameMode('two-player');
            setDifficulty('medium');
            
            // 为「再玩一次」按钮添加事件监听器
            document.getElementById('play-again-btn').addEventListener('click', playAgain);
            
            logDebug('游戏初始化完成！');
        }
        
        // 页面加载完成后初始化游戏
        window.addEventListener('load', initGame);
    </script>
</body>
</html>